#include <iostream> // Підключення бібліотеки для стандартного введення та виведення
#include <vector> // Підключення бібліотеки для використання векторів
#include <queue> // Підключення бібліотеки для використання черги

using namespace std; // Використання простору імен для стандартних символів C++

// Визначення структури вузла дерева
struct TreeNode { // Визначення користувацької структури "TreeNode"
    int val; // Поле "val" для зберігання значення вузла
    TreeNode* left; // Вказівник на лівого нащадка вузла
    TreeNode* right; // Вказівник на правого нащадка вузла
    TreeNode(int x) : val(x), left(NULL), right(NULL) {} // Конструктор з параметром для ініціалізації полів
};

// Функція для створення збалансованого бінарного дерева з відсортованого масиву
TreeNode* sortedArrayToBST(vector<int>& nums, int start, int end) { // Оголошення функції з параметрами
    if (start > end) return NULL; // Умова виходу: якщо індекс початку більше за індекс кінця, повертається NULL

    // Вибір середнього елемента масиву як кореня для забезпечення балансу
    int mid = start + (end - start) / 2; // Обчислення середнього індексу масиву
    TreeNode* node = new TreeNode(nums[mid]); // Створення нового вузла з середнім значенням масиву

    // Рекурсивно будуємо ліве та праве піддерева
    node->left = sortedArrayToBST(nums, start, mid - 1); // Рекурсивний виклик для побудови лівого піддерева
    node->right = sortedArrayToBST(nums, mid + 1, end); // Рекурсивний виклик для побудови правого піддерева

    return node; // Повертаємо створений вузол
}

// Функція для виведення всіх вершин дерева
void printTree(TreeNode* root) { // Оголошення функції з параметром
    if (!root) return; // Умова виходу: якщо дерево порожнє, функція завершується

    queue<TreeNode*> q; // Створення черги для обходу дерева в ширину
    q.push(root); // Додавання кореня в чергу

    while (!q.empty()) { // Поки черга не порожня
        TreeNode* current = q.front(); // Отримання початкового елемента черги
        q.pop(); // Видалення першого елемента з черги

        cout << current->val << " "; // Виведення значення поточного вузла

        if (current->left != NULL) // Якщо є лівий нащадок
            q.push(current->left); // Додати лівого нащадка до черги
        if (current->right != NULL) // Якщо є правий нащадок
            q.push(current->right); // Додати правого нащадка до черги
    }
}

int main() { // Головна функція програми
    vector<int> nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // Відсортований масив для створення дерева
    TreeNode* root = sortedArrayToBST(nums, 0, nums.size() - 1); // Створення збалансованого дерева з відсортованого масиву

    cout << "\nTree tops: "; // Виведення заголовка
    printTree(root); // Виведення всіх вершин дерева
    cout << endl; // Перехід на новий рядок

    return 0; // Код завершення програми
}
